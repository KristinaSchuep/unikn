)
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux)
plot_col(pal_Bordeaux, ylen = 0.1)
plot_col(pal_Bordeaux, ylen = 0.1, dist = 0.1)
plot_col(pal_Bordeaux, ylen = 0.1, dist = -0.1)
plot_col(pal_Bordeaux, ylen = 0.1, dist = -0.1, shape = "circle")
plot_col(pal_Bordeaux, xlen = 0.1, dist = -0.1, shape = "circle")
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
plot(x = 0, type = "n", xlim = c(0, len_x), ylim = c(0, 2))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
plot_shape(box_x = as.numeric(colors["pos_x"]),  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = colors["color"],  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux, xlen = 0.1, dist = -0.1, shape = "circle")
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
plot(x = 0, type = "n", xlim = c(0, len_x), ylim = c(0, 2))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
# col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux, xlen = 0.1, dist = -0.1, shape = "circle")
ypos
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
plot(x = 0, type = "n", xlim = c(0, len_x), ylim = c(0, 2))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
# col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
ypos <- rep(ypos, length.out = len_x)  # length out ypos to the length of x.
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
ypos
plot_col(pal_Bordeaux, xlen = 0.1, dist = -0.1, shape = "circle")
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
pos_x
ypos <- rep(ypos, length.out = len_x)  # length out ypos to the length of x.
ypos
pos_x
xlen
ylen
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
plot(x = 0, type = "n", xlim = c(0, len_x), ylim = c(0, 2))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
# col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
ypos <- rep(ypos, length.out = len_x)  # length out ypos to the length of x.
xlen <- rep(xlen, length.out = len_x)
ylen <- rep(ylen, length.out = len_x)
## Plotting:
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux, xlen = 0.1, dist = -0.1, shape = "circle")
plot_col(pal_Bordeaux, xlen = 1, dist = -0.1, shape = "circle")
plot_col(pal_Bordeaux, xlen = 1, dist = 0.1, shape = "circle")
plot_shape <- function(box_x, box_y,  # midpoint of the rectangle.
col_fill,  # color for filling.
col_brd = NA,
xlen = 1, ylen = 1,  # height of the axis lengths.
shape = "rect",  # shape parameter.
...
) {
## Robustify inputs: -----
## TODO!
## Prepare inpust for vectorized solution? -----
## For rectangular shape: -----
if (shape == "rect") {
# rect(xleft  = (box_x - xlen/2), ybottom = (box_y - ylen/2),
#      xright = (box_x + xlen/2), ytop    = (box_y + ylen/2),
#      col = unlist(col_fill),
#      border = col_brd
#      # lwd = box.lwd,
#      # ...  # TODO: ... does not work?!
# )
symbols(x = box_x, y = box_y, rectangles = cbind(xlen, ylen),
add = TRUE,
inches = FALSE,  # use unit on x axis.
fg = col_brd,  # line color.
bg = col_fill  # filling.
)
}
## For circles:  -----
if (shape == "circle") {
symbols(x = box_x, y = box_y, circles = xlen/2,  # only uses xlen!
add = TRUE,
inches = FALSE,  # use unit on x axis.
fg = col_brd,  # line color.
bg = col_fill  # filling.
)
}
}
plot_col(pal_Bordeaux, xlen = 1, dist = 0.1, shape = "circle")
plot_col(pal_Bordeaux, xlen = 1, dist = 0.1, shape = "rect")
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
xlim <- c(0 - distance * len_x, 1 + distance * len_x)
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, max(ypos)))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
# col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
ypos <- rep(ypos, length.out = len_x)  # length out ypos to the length of x.
xlen <- rep(xlen, length.out = len_x)
ylen <- rep(ylen, length.out = len_x)
## Plotting:
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux, xlen = 1, dist = 0.1, shape = "rect")
## Get key parameters:
len_x <- length(x)
xlim <- c(0 - distance * len_x, 1 + distance * len_x)
xlim
distance
distance * len_x
len_x
0 - distance * len_x
distance * len_x
plot_col(pal_Bordeaux, xlen = 1, dist = 0.1, shape = "rect")
plot_col(pal_Bordeaux, xlen = 1, dist = 0.2, shape = "rect")
0 - distance * len_x
distance * len_x
distance
0 - distance * len_x
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
if (distance > 0) {
xlim <- c(0 - distance * len_x, 1 + distance * len_x)
} else {
xlim <- c(0, len_x)
}
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, max(ypos)))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
# col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
ypos <- rep(ypos, length.out = len_x)  # length out ypos to the length of x.
xlen <- rep(xlen, length.out = len_x)
ylen <- rep(ylen, length.out = len_x)
## Plotting:
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux, xlen = 1, dist = 0.2, shape = "rect")
plot_col(pal_Bordeaux, xlen = 1, dist = -0.2, shape = "rect")
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
if (distance > 0) {
xlim <- c(0 - distance * len_x, 1 + distance * len_x)
} else {
xlim <- c(0, len_x)
}
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, 2))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
# col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
ypos <- rep(ypos, length.out = len_x)  # length out ypos to the length of x.
xlen <- rep(xlen, length.out = len_x)
ylen <- rep(ylen, length.out = len_x)
## Plotting:
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux, xlen = 1, dist = -0.2, shape = "rect")
plot_col(pal_Bordeaux, xlen = 1, dist = 0.2, shape = "rect")
plot_col <- function(x,  # a *vector* of colors to be plotted.
ypos = 1,  # position on y axis.
shape = "rect",
xlen = 1, ylen = 1,
distance = 0,  # distance of shapes (to be taken from size).
plot.new = TRUE,  # TODO: Set to false once done!
...
) {
## 1. Control inputs: -------------------------------------
## Robustify parameters:
# TODO!
## Get key parameters:
len_x <- length(x)
## Should a new plot be created?
if (plot.new) {
if (distance > 0) {
xlim <- c(0 - distance * len_x, len_x * (1 + distance))
} else {
xlim <- c(0, len_x)
}
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, 2))  # create empty plot.
} else {
## Check, whether a graphic device is available:
if (dev.cur() == 1) {
stop("No graphic device to be plotted on.  Please open a plot or set plot.new to 'TRUE'.")
}
}
## 2. Calculate position parameters: ------------------------
# Define positions of shape centers:
pos_x <- 1:len_x - 0.5
# change the distances:
mid <- mean(pos_x)  # get midpoint.
add <- cumsum(rep(distance, sum(pos_x < mid)))  # values to be added to the first half.
sub <- add * (-1)  # values to be subtracted from the second half.
pos_x <- pos_x + if(len_x %% 2 == 0) c(rev(sub), add) else  # for even numbers no center position needed.
c(rev(sub), 0, add)  # include the middle for uneven numbers.
## 3. Plot all shapes: --------------------------------------
# col_pos <- cbind(color = unlist(x), pos_x = pos_x)  # data to be plotted.
#apply(col_pos, MAR = 1, function(colors) {
ypos <- rep(ypos, length.out = len_x)  # length out ypos to the length of x.
xlen <- rep(xlen, length.out = len_x)
ylen <- rep(ylen, length.out = len_x)
## Plotting:
plot_shape(box_x = pos_x,  # x positions of the shapes.
box_y = ypos,  # position in y dimension (given).
xlen = xlen, ylen = ylen,  # length of the axes.
col_fill = unlist(x),  # filling color.
shape = shape,  # shape parameter.
...
)
#}
# )
# TODO: Is there a quicker (vectorized) way?
## Vectorize in previous function? (i.e., sapply over vectors of input values?)
}
plot_col(pal_Bordeaux, xlen = 1, dist = 0.2, shape = "rect")
plot_col(pal_Bordeaux, xlen = 1, dist = 0, shape = "rect")
plot_col(pal_Bordeaux, xlen = 1, dist = 0.1, shape = "rect")
plot_col(pal_Bordeaux, xlen = 1, dist = -0.1, shape = "rect")
plot_col(pal_Bordeaux, xlen = 1, dist = -0.4, shape = "rect")
x=0:1000
plot(x = x, y = x^0.3)
plot(x = x, y = x^1)
plot(x = x, y = x^02)
plot(x = x, y = x^0.1)
