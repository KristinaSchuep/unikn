## Determine xlim based on distance, maximum number of colors, and box length:
xlim <- c(0 - distance, (1 + distance) * xlen) * max_num * xlen
# Determine ylim as number of colors in the palette:
ylim <- length(pal)
## Bind palettes to color index:
pal_mat <- cbind(pal, length(pal):1)  # TODO: Note, that a single palette needs to be a list of length 1!
## TODO: How to handle inputs of multiple palettes?  Merge them or display them for comparison.
## Possible solution: (a) 1 list entry --> details; (b) more than 1 list entry --> comparison:
if ( length(pal) > 1 ) {
## Set margins:
par(mar = c(3, 6, 3, 1))
# Create empty plot:
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, ylim),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = "See all KN palettes",
bty = "n"
)
## TODO: Add fancy KN-design stuff!
## Add the color vectors:
apply(pal_mat, MAR = 1, FUN = function(row) {
# print(row[[2]])
plot_col(x = row[[1]], ypos = row[2], plot.new = FALSE, ylen = 0.8, col_brd = "grey", lwd = 1)
})
# TODO: Can I allow to plot the matrix in a vectorized way (unlisting somewhere)?
## Add color names and indices:
text(x = -1, y = 1:length(pal), labels = rev(pal_nm), pos = 2, xpd = TRUE)
text(x = seq(0.5, max_num - 0.5, by = 1), y = -1,
labels = paste0("[", 1:max_num, "]"), pos = 3, xpd = TRUE,
cex = 0.7)
} else {  # if only a list of 1 is specified:
# 2. Detail view: ------------
## Preps:
pal <- unlist(pal)  # TODO: This essentially changes the length of the color vector.  FInd better solution!
## Set margins:
par(mar = c(3, 2, 3, 1))
plot(x = 0, type = "n", xlim = xlim, ylim = c(-1, 2),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = paste("See palette", pal_nm),
bty = "n"
)  # create empty plot.
## Text elements:
txt_pos <- seq(0.5, length(pal) - 0.5)
abline(h = c(0.6, 1.2, 1.8, -0.1, -0.6, -0.75, -0.90),
v = txt_pos,
col = grey(0.5, 0.3))
## Determine whether to display hex values:
if ( is.null(hex) ) {
hex <- ifelse(strwidth("#XXXXXX") * max_num > xlim[2], FALSE, TRUE)
}
## Determine, whether to display rgb values:
if ( is.null(rgb) ) {
rgb <- TRUE  # TODO: Determiune also dynamically?
}
# Plot rectangles:
plot_col(x = pal, ypos = 0.6, plot.new = FALSE, ylen = 0.5, col_brd = "grey", lwd = 1)
# Plot circles:
plot_col(x = pal, ypos = 1.2, plot.new = FALSE, xlen = 0.5, shape = "circle")
## Color names:
text(x = txt_pos, y = 1.8, labels = names(pal), # pos = 3,
srt = 45, xpd = TRUE, offset = 1,
adj = c(0, 0))
## Color indices:
text(x = txt_pos, y = -0.1, labels = paste0("[", 1:length(pal), "]"), pos = 3, xpd = TRUE,
cex = 1)
## Hex values:
if ( hex ) {
text(x = -0.1, y = -0.3, labels = "Hex", font = 2, pos = 3, xpd = TRUE, cex = 1)
text(x = txt_pos, y = -0.3, labels = pal, pos = 3, xpd = TRUE,
cex = 1)
}
## RGB values:
if ( rgb ) {
y_rgb <- c(-0.6, -0.75, -0.9)
text(x = rep(-0.1, 3),
y = y_rgb,
labels = c("R", "G", "B"), font = 2,
pos = 3, xpd = TRUE,
cex = 1)
text(x = matrix(rep(txt_pos, 3), nrow = 3, byrow = TRUE),
y = matrix(rep(y_rgb, length(txt_pos) + 1), nrow = 3),
labels = col2rgb(pal),
pos = 3, xpd = TRUE,
cex = 1)
}
}
# Reset plotting parameters:
par(op)
## Invisibly return palette(s):
invisible(pal)
}
b <- seepal(pal = list(pal_unikn_pair))  # return one long palette (hex not displayed by default.)
seepal <- function(pal = "all",  # which palette to output?
hex = NULL,  # determine by crowdedness, whether hex values should be shown in detail view.
rgb = NULL   # determine, whether rgb values should be shown in detail view (defaults to TRUE)
) {
## 0. Preparations: ---------
op <- par(no.readonly = TRUE)  # save original plotting settings.
# Robustify inputs:
if (!(is.null(hex) | is.logical(hex))) stop("Please specify a valid value for 'hex'.")
if (!(is.null(rgb) | is.logical(rgb))) stop("Please specify a valid value for 'rgb'.")
## 1. Overview function: ------
if (pal == "all") {
# 1.1 Get all color palettes with the prefix "_pal" from the environment:
pal_names <- apropos("pal_")  # get all unikn palettes.
pal_ls <- sapply(pal_names, get)
## Indicator, whether these are color palettes:
is_pal <- lapply(pal_ls, FUN = function(x) {
if (!typeof(x) %in% c("vector", "list")) {
is_color <- FALSE
} else {
is_color <- isHexCol(color = x)
}
return(all(is_color))  # are all entries colors?
})
## Get the palettes:
pal <- pal_ls[unlist(is_pal)]
} else {
# TODO: Getting the single palette.
}
## Check if palette is non-empty:
if (length(pal) == 0) {
stop("No palettes defined.")
# return(NULL)
}
pal_nm <- gsub("pal_", "", names(pal))  # get palette names from listnames.
## Plotting preparations:
distance <- 0  # set distance.
xlen <- 1  # set x length of boxes.
# TODO: Allow user to set these inputs?
## Get maximum number of colors:
max_num <- max(unlist(lapply(pal, FUN = length)))
## Determine xlim based on distance, maximum number of colors, and box length:
xlim <- c(0 - distance, (1 + distance) * xlen) * max_num * xlen
# Determine ylim as number of colors in the palette:
ylim <- length(pal)
## Bind palettes to color index:
pal_mat <- cbind(pal, length(pal):1)  # TODO: Note, that a single palette needs to be a list of length 1!
## TODO: How to handle inputs of multiple palettes?  Merge them or display them for comparison.
## Possible solution: (a) 1 list entry --> details; (b) more than 1 list entry --> comparison:
if ( length(pal) > 1 ) {
## Set margins:
par(mar = c(3, 6, 3, 1))
# Create empty plot:
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, ylim),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = "See all KN palettes",
bty = "n"
)
## TODO: Add fancy KN-design stuff!
## Add the color vectors:
apply(pal_mat, MAR = 1, FUN = function(row) {
# print(row[[2]])
plot_col(x = row[[1]], ypos = row[2], plot.new = FALSE, ylen = 0.8, col_brd = "grey", lwd = 1)
})
# TODO: Can I allow to plot the matrix in a vectorized way (unlisting somewhere)?
## Add color names and indices:
text(x = -1, y = 1:length(pal), labels = rev(pal_nm), pos = 2, xpd = TRUE)
text(x = seq(0.5, max_num - 0.5, by = 1), y = -1,
labels = paste0("[", 1:max_num, "]"), pos = 3, xpd = TRUE,
cex = 0.7)
} else {  # if only a list of 1 is specified:
# 2. Detail view: ------------
## Preps:
pal <- unlist(pal)  # TODO: This essentially changes the length of the color vector.  FInd better solution!
## Set margins:
par(mar = c(3, 2, 3, 1))
plot(x = 0, type = "n", xlim = xlim, ylim = c(-1, 2),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = paste("See palette", pal_nm),
bty = "n"
)  # create empty plot.
## Text elements:
txt_pos <- seq(0.5, length(pal) - 0.5)
abline(h = c(0.6, 1.2, 1.4, -0.1, -0.6, -0.75, -0.90),
v = txt_pos,
col = grey(0.5, 0.3))
## Determine whether to display hex values:
if ( is.null(hex) ) {
hex <- ifelse(strwidth("#XXXXXX") * max_num > xlim[2], FALSE, TRUE)
}
## Determine, whether to display rgb values:
if ( is.null(rgb) ) {
rgb <- TRUE  # TODO: Determiune also dynamically?
}
# Plot rectangles:
plot_col(x = pal, ypos = 0.6, plot.new = FALSE, ylen = 0.5, col_brd = "grey", lwd = 1)
# Plot circles:
plot_col(x = pal, ypos = 1.2, plot.new = FALSE, xlen = 0.5, shape = "circle")
## Color names:
text(x = txt_pos, y = 1.4, labels = names(pal), # pos = 3,
srt = 45, xpd = TRUE, offset = 1,
adj = c(0, 0))
## Color indices:
text(x = txt_pos, y = -0.1, labels = paste0("[", 1:length(pal), "]"), pos = 3, xpd = TRUE,
cex = 1)
## Hex values:
if ( hex ) {
text(x = -0.1, y = -0.3, labels = "Hex", font = 2, pos = 3, xpd = TRUE, cex = 1)
text(x = txt_pos, y = -0.3, labels = pal, pos = 3, xpd = TRUE,
cex = 1)
}
## RGB values:
if ( rgb ) {
y_rgb <- c(-0.6, -0.75, -0.9)
text(x = rep(-0.1, 3),
y = y_rgb,
labels = c("R", "G", "B"), font = 2,
pos = 3, xpd = TRUE,
cex = 1)
text(x = matrix(rep(txt_pos, 3), nrow = 3, byrow = TRUE),
y = matrix(rep(y_rgb, length(txt_pos) + 1), nrow = 3),
labels = col2rgb(pal),
pos = 3, xpd = TRUE,
cex = 1)
}
}
# Reset plotting parameters:
par(op)
## Invisibly return palette(s):
invisible(pal)
}
b <- seepal(pal = list(pal_unikn_pair))  # return one long palette (hex not displayed by default.)
b
c <- seepal(pal = list(pal_Bordeaux), hex = TRUE)
seepal <- function(pal = "all",  # which palette to output?
hex = NULL,  # determine by crowdedness, whether hex values should be shown in detail view.
rgb = NULL,   # determine, whether rgb values should be shown in detail view (defaults to TRUE)
col_brd = NULL
) {
## 0. Preparations: ---------
op <- par(no.readonly = TRUE)  # save original plotting settings.
# Robustify inputs:
if (!(is.null(hex) | is.logical(hex))) stop("Please specify a valid value for 'hex'.")
if (!(is.null(rgb) | is.logical(rgb))) stop("Please specify a valid value for 'rgb'.")
## 1. Overview function: ------
if (pal == "all") {
# 1.1 Get all color palettes with the prefix "_pal" from the environment:
pal_names <- apropos("pal_")  # get all unikn palettes.
pal_ls <- sapply(pal_names, get)
## Indicator, whether these are color palettes:
is_pal <- lapply(pal_ls, FUN = function(x) {
if (!typeof(x) %in% c("vector", "list")) {
is_color <- FALSE
} else {
is_color <- isHexCol(color = x)
}
return(all(is_color))  # are all entries colors?
})
## Get the palettes:
pal <- pal_ls[unlist(is_pal)]
} else {
# TODO: Getting the single palette.
}
## Check if palette is non-empty:
if (length(pal) == 0) {
stop("No palettes defined.")
# return(NULL)
}
pal_nm <- gsub("pal_", "", names(pal))  # get palette names from listnames.
## Plotting preparations:
distance <- 0  # set distance.
xlen <- 1  # set x length of boxes.
# TODO: Allow user to set these inputs?
## Get maximum number of colors:
max_num <- max(unlist(lapply(pal, FUN = length)))
## Determine xlim based on distance, maximum number of colors, and box length:
xlim <- c(0 - distance, (1 + distance) * xlen) * max_num * xlen
# Determine ylim as number of colors in the palette:
ylim <- length(pal)
## Bind palettes to color index:
pal_mat <- cbind(pal, length(pal):1)  # TODO: Note, that a single palette needs to be a list of length 1!
## TODO: How to handle inputs of multiple palettes?  Merge them or display them for comparison.
## Possible solution: (a) 1 list entry --> details; (b) more than 1 list entry --> comparison:
if ( length(pal) > 1 ) {
## Set margins:
par(mar = c(3, 6, 3, 1))
# Create empty plot:
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, ylim),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = "See all KN palettes",
bty = "n"
)
## TODO: Add fancy KN-design stuff!
## Add the color vectors:
apply(pal_mat, MAR = 1, FUN = function(row) {
# print(row[[2]])
plot_col(x = row[[1]], ypos = row[2], plot.new = FALSE, ylen = 0.8, col_brd = "grey", lwd = 1)
})
# TODO: Can I allow to plot the matrix in a vectorized way (unlisting somewhere)?
## Add color names and indices:
text(x = -1, y = 1:length(pal), labels = rev(pal_nm), pos = 2, xpd = TRUE)
text(x = seq(0.5, max_num - 0.5, by = 1), y = -1,
labels = paste0("[", 1:max_num, "]"), pos = 3, xpd = TRUE,
cex = 0.7)
} else {  # if only a list of 1 is specified:
# 2. Detail view: ------------
## Preps:
pal <- unlist(pal)  # TODO: This essentially changes the length of the color vector.  FInd better solution!
## Set margins:
par(mar = c(3, 2, 3, 1))
plot(x = 0, type = "n", xlim = xlim, ylim = c(-1, 2),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = paste("See palette", pal_nm),
bty = "n"
)  # create empty plot.
## Text elements:
txt_pos <- seq(0.5, length(pal) - 0.5)
abline(h = c(0.6, 1.2, 1.6, -0.1, -0.6, -0.75, -0.90),
v = txt_pos,
col = grey(0.5, 0.3))
## Determine whether to display hex values:
if ( is.null(hex) ) {
hex <- ifelse(strwidth("#XXXXXX") * max_num > xlim[2], FALSE, TRUE)
}
## Determine, whether to display rgb values:
if ( is.null(rgb) ) {
rgb <- TRUE  # TODO: Determiune also dynamically?
}
# Plot rectangles:
plot_col(x = pal, ypos = 0.6, plot.new = FALSE, ylen = 0.5, col_brd = col_brd, lwd = 1)
# Plot circles:
plot_col(x = pal, ypos = 1.2, plot.new = FALSE, xlen = 0.5, shape = "circle")
## Color names:
text(x = txt_pos, y = 1.6, labels = names(pal), # pos = 3,
srt = 45, xpd = TRUE, offset = 1,
adj = c(0, 0))
## Color indices:
text(x = txt_pos, y = -0.1, labels = paste0("[", 1:length(pal), "]"), pos = 3, xpd = TRUE,
cex = 1)
## Hex values:
if ( hex ) {
text(x = -0.1, y = -0.3, labels = "Hex", font = 2, pos = 3, xpd = TRUE, cex = 1)
text(x = txt_pos, y = -0.3, labels = pal, pos = 3, xpd = TRUE,
cex = 1)
}
## RGB values:
if ( rgb ) {
y_rgb <- c(-0.6, -0.75, -0.9)
text(x = rep(-0.1, 3),
y = y_rgb,
labels = c("R", "G", "B"), font = 2,
pos = 3, xpd = TRUE,
cex = 1)
text(x = matrix(rep(txt_pos, 3), nrow = 3, byrow = TRUE),
y = matrix(rep(y_rgb, length(txt_pos) + 1), nrow = 3),
labels = col2rgb(pal),
pos = 3, xpd = TRUE,
cex = 1)
}
}
seepal <- function(pal = "all",  # which palette to output?
hex = NULL,  # determine by crowdedness, whether hex values should be shown in detail view.
rgb = NULL,   # determine, whether rgb values should be shown in detail view (defaults to TRUE)
col_brd = NULL
) {
## 0. Preparations: ---------
op <- par(no.readonly = TRUE)  # save original plotting settings.
# Robustify inputs:
if (!(is.null(hex) | is.logical(hex))) stop("Please specify a valid value for 'hex'.")
if (!(is.null(rgb) | is.logical(rgb))) stop("Please specify a valid value for 'rgb'.")
## 1. Overview function: ------
if (pal == "all") {
# 1.1 Get all color palettes with the prefix "_pal" from the environment:
pal_names <- apropos("pal_")  # get all unikn palettes.
pal_ls <- sapply(pal_names, get)
## Indicator, whether these are color palettes:
is_pal <- lapply(pal_ls, FUN = function(x) {
if (!typeof(x) %in% c("vector", "list")) {
is_color <- FALSE
} else {
is_color <- isHexCol(color = x)
}
return(all(is_color))  # are all entries colors?
})
## Get the palettes:
pal <- pal_ls[unlist(is_pal)]
} else {
# TODO: Getting the single palette.
}
## Check if palette is non-empty:
if (length(pal) == 0) {
stop("No palettes defined.")
# return(NULL)
}
pal_nm <- gsub("pal_", "", names(pal))  # get palette names from listnames.
## Plotting preparations:
distance <- 0  # set distance.
xlen <- 1  # set x length of boxes.
# TODO: Allow user to set these inputs?
## Get maximum number of colors:
max_num <- max(unlist(lapply(pal, FUN = length)))
## Determine xlim based on distance, maximum number of colors, and box length:
xlim <- c(0 - distance, (1 + distance) * xlen) * max_num * xlen
# Determine ylim as number of colors in the palette:
ylim <- length(pal)
## Bind palettes to color index:
pal_mat <- cbind(pal, length(pal):1)  # TODO: Note, that a single palette needs to be a list of length 1!
## TODO: How to handle inputs of multiple palettes?  Merge them or display them for comparison.
## Possible solution: (a) 1 list entry --> details; (b) more than 1 list entry --> comparison:
if ( length(pal) > 1 ) {
## Set margins:
par(mar = c(3, 6, 3, 1))
# Create empty plot:
plot(x = 0, type = "n", xlim = xlim, ylim = c(0, ylim),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = "See all KN palettes",
bty = "n"
)
## TODO: Add fancy KN-design stuff!
## Add the color vectors:
apply(pal_mat, MAR = 1, FUN = function(row) {
# print(row[[2]])
plot_col(x = row[[1]], ypos = row[2], plot.new = FALSE, ylen = 0.8, col_brd = "grey", lwd = 1)
})
# TODO: Can I allow to plot the matrix in a vectorized way (unlisting somewhere)?
## Add color names and indices:
text(x = -1, y = 1:length(pal), labels = rev(pal_nm), pos = 2, xpd = TRUE)
text(x = seq(0.5, max_num - 0.5, by = 1), y = -1,
labels = paste0("[", 1:max_num, "]"), pos = 3, xpd = TRUE,
cex = 0.7)
} else {  # if only a list of 1 is specified:
# 2. Detail view: ------------
## Preps:
pal <- unlist(pal)  # TODO: This essentially changes the length of the color vector.  FInd better solution!
## Set margins:
par(mar = c(3, 2, 3, 1))
plot(x = 0, type = "n", xlim = xlim, ylim = c(-1, 2),
xaxt = "n", yaxt = "n",  # hide axes.
xlab = "", ylab = "", main = paste("See palette", pal_nm),
bty = "n"
)  # create empty plot.
## Text elements:
txt_pos <- seq(0.5, length(pal) - 0.5)
abline(h = c(0.6, 1.2, 1.6, -0.1, -0.6, -0.75, -0.90),
v = txt_pos,
col = grey(0.5, 0.3))
## Determine whether to display hex values:
if ( is.null(hex) ) {
hex <- ifelse(strwidth("#XXXXXX") * max_num > xlim[2], FALSE, TRUE)
}
## Determine, whether to display rgb values:
if ( is.null(rgb) ) {
rgb <- TRUE  # TODO: Determiune also dynamically?
}
# Plot rectangles:
plot_col(x = pal, ypos = 0.6, plot.new = FALSE, ylen = 0.5, col_brd = col_brd, lwd = 1)
# Plot circles:
plot_col(x = pal, ypos = 1.2, plot.new = FALSE, xlen = 0.5, shape = "circle")
## Color names:
text(x = txt_pos, y = 1.6, labels = names(pal), # pos = 3,
srt = 45, xpd = TRUE, offset = 1,
adj = c(0, 0))
## Color indices:
text(x = txt_pos, y = -0.1, labels = paste0("[", 1:length(pal), "]"), pos = 3, xpd = TRUE,
cex = 1)
## Hex values:
if ( hex ) {
text(x = -0.1, y = -0.3, labels = "Hex", font = 2, pos = 3, xpd = TRUE, cex = 1)
text(x = txt_pos, y = -0.3, labels = pal, pos = 3, xpd = TRUE,
cex = 1)
}
## RGB values:
if ( rgb ) {
y_rgb <- c(-0.6, -0.75, -0.9)
text(x = rep(-0.1, 3),
y = y_rgb,
labels = c("R", "G", "B"), font = 2,
pos = 3, xpd = TRUE,
cex = 1)
text(x = matrix(rep(txt_pos, 3), nrow = 3, byrow = TRUE),
y = matrix(rep(y_rgb, length(txt_pos) + 1), nrow = 3),
labels = col2rgb(pal),
pos = 3, xpd = TRUE,
cex = 1)
}
}
# Reset plotting parameters:
par(op)
## Invisibly return palette(s):
invisible(pal)
}
b <- seepal(pal = list(pal_unikn_pair))  # return one long palette (hex not displayed by default.)
c <- seepal(pal = list(pal_Bordeaux), hex = TRUE)
pal_which
pal_which()
colorRamp()
colorRamp(pal_Bordeaux)
?colorRamp
colorRampPalette(colors = c(pal_seeblau, pal_grau, pal_peach))
col_scale()
col_scale(10)
# ## Demo:
n <- 10
col_gradient(n)
plot(rep(1, n), col = (col_gradient(n)), pch = 19, cex = 10)
colorRampPalette(colors = c(pal_seeblau, pal_grau, pal_peach))
## Examples:
# col_gradient <- colorRampPalette(colors = c("firebrick", "gold", "forestgreen", "steelblue"))
# col_gradient <- colorRampPalette(colors = pal_unikn_plus)
#
# col_gradient <- colorRampPalette(colors = c(seeblau, peach))  # 2 individual colors
# col_gradient <- colorRampPalette(colors = c(pal_seeblau[2], pal_karpfenblau[5]))  # 2 colors from palettes
# col_gradient <- colorRampPalette(colors = c(pal_seeblau, pal_petrol))  # 2 palettes
#
# col_gradient <- colorRampPalette(colors = c(seeblau, grau, peach))  # 3 colors
# col_gradient <- colorRampPalette(colors = c(pal_seeblau[4], pal_grau[2], pal_peach[5]))  # 3 colors from palettes
col_gradient <- colorRampPalette(colors = c(pal_seeblau, pal_grau, pal_peach))  # 3 palettes
col_gradient
col_gradient(n)
plot(rep(1, n), col = (col_gradient(n)), pch = 19, cex = 10)
plot(rep(1, n), col = (col_gradient(n)), pch = 15, cex = 3)
text(x = 10, y = 1.2, labels = col_gradient(n)[10])
